"""
Vulnerability Scanner Module for Agent

This module provides vulnerability scanning capabilities for the agent component.
It scans the local system for security vulnerabilities and returns the results.
"""

import os
import socket
import subprocess
import re
import json
import platform
import time
import sys
import ctypes
import struct
from datetime import datetime

# Define vulnerability severity levels
SEVERITY_CRITICAL = "critical"
SEVERITY_HIGH = "high"
SEVERITY_MEDIUM = "medium"
SEVERITY_LOW = "low"

# Define vulnerability status
STATUS_OPEN = "open"
STATUS_IN_PROGRESS = "in_progress"
STATUS_RESOLVED = "resolved"
STATUS_FALSE_POSITIVE = "false_positive"

class VulnerabilityScanner:
    """
    Vulnerability scanner for the agent component.
    Scans the local system for security vulnerabilities.
    """

    def __init__(self, scan_type="standard"):
        """
        Initialize the vulnerability scanner.

        Args:
            scan_type (str): Type of scan to perform (quick, standard, deep)
        """
        self.scan_type = scan_type
        self.vulnerabilities = []
        self.scan_start_time = None
        self.scan_end_time = None
        self.os_info = self._get_os_info()

        # Load vulnerability database
        self._load_vulnerability_database()

    def _load_vulnerability_database(self):
        """Load vulnerability definitions from embedded database."""
        # Initialize empty database
        self.vuln_db = {
            'service_vulns': {},
            'os_vulns': {},
            'web_vulns': {},
            'config_vulns': {}
        }

        # Load service vulnerabilities
        self.vuln_db['service_vulns'] = {
            "SV-001": {
                "title": "OpenSSH < 7.7 Username Enumeration",
                "description": "OpenSSH versions prior to 7.7 are vulnerable to username enumeration via timing attacks.",
                "severity": SEVERITY_MEDIUM,
                "cve_id": "CVE-2018-15473",
                "affected_services": ["ssh"],
                "version_pattern": "OpenSSH_([0-6]\\.|7\\.[0-6])",
                "remediation": "Upgrade OpenSSH to version 7.7 or later."
            },
            "SV-002": {
                "title": "SMB Protocol Version 1 Enabled",
                "description": "SMB protocol version 1 is enabled. SMBv1 has multiple known security vulnerabilities and has been deprecated.",
                "severity": SEVERITY_HIGH,
                "affected_services": ["smb", "microsoft-ds"],
                "remediation": "Disable SMBv1 and use SMBv2 or SMBv3 instead. For Windows systems, this can be done through Group Policy or Registry settings."
            },
            "SV-003": {
                "title": "Telnet Service Enabled",
                "description": "Telnet service is enabled. Telnet transmits data in cleartext, including authentication credentials.",
                "severity": SEVERITY_HIGH,
                "affected_services": ["telnet"],
                "remediation": "Disable Telnet service and use SSH instead for secure remote access."
            }
        }

        # Load OS vulnerabilities
        self.vuln_db['os_vulns'] = {
            "OV-001": {
                "title": "Windows SMB Remote Code Execution Vulnerability (MS17-010)",
                "description": "The system is vulnerable to the EternalBlue exploit (MS17-010), which allows remote code execution.",
                "severity": SEVERITY_CRITICAL,
                "cve_id": "CVE-2017-0144",
                "affected_os": ["windows"],
                "affected_versions": ["windows 7", "windows server 2008", "windows 8", "windows server 2012"],
                "remediation": "Install the security update from Microsoft (MS17-010)."
            },
            "OV-002": {
                "title": "Outdated Windows Operating System",
                "description": "The system is running an outdated version of Windows that no longer receives security updates.",
                "severity": SEVERITY_HIGH,
                "affected_os": ["windows xp", "windows vista", "windows server 2003"],
                "remediation": "Upgrade to a supported version of Windows."
            },
            "OV-003": {
                "title": "Windows Print Spooler Remote Code Execution Vulnerability (PrintNightmare)",
                "description": "The system is vulnerable to the PrintNightmare vulnerability, which allows remote code execution via the Print Spooler service.",
                "severity": SEVERITY_CRITICAL,
                "cve_id": "CVE-2021-34527",
                "affected_os": ["windows"],
                "remediation": "Install the latest security updates from Microsoft and disable the Print Spooler service if not needed."
            }
        }

        # Load configuration vulnerabilities
        self.vuln_db['config_vulns'] = {
            "CV-001": {
                "title": "User Account Control (UAC) Disabled",
                "description": "User Account Control (UAC) is disabled, which reduces the security of the system.",
                "severity": SEVERITY_MEDIUM,
                "affected_os": ["windows"],
                "remediation": "Enable User Account Control (UAC) in the Control Panel."
            },
            "CV-002": {
                "title": "Windows Defender Real-time Protection Disabled",
                "description": "Windows Defender real-time protection is disabled, leaving the system vulnerable to malware.",
                "severity": SEVERITY_HIGH,
                "affected_os": ["windows"],
                "remediation": "Enable Windows Defender real-time protection in Windows Security settings."
            },
            "CV-003": {
                "title": "Automatic Updates Disabled",
                "description": "Automatic updates are disabled, preventing the system from receiving security patches.",
                "severity": SEVERITY_MEDIUM,
                "affected_os": ["windows", "linux"],
                "remediation": "Enable automatic updates in the system settings."
            }
        }

    def _get_os_info(self):
        """Get information about the operating system."""
        os_info = {
            'os_name': platform.system(),
            'os_version': platform.version(),
            'os_release': platform.release(),
            'os_arch': platform.machine()
        }

        # Get more detailed Windows version information
        if os_info['os_name'].lower() == 'windows':
            try:
                import winreg
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion") as key:
                    os_info['product_name'] = winreg.QueryValueEx(key, "ProductName")[0]
                    os_info['build_number'] = winreg.QueryValueEx(key, "CurrentBuildNumber")[0]
                    try:
                        os_info['display_version'] = winreg.QueryValueEx(key, "DisplayVersion")[0]
                    except:
                        os_info['display_version'] = ""
            except:
                pass

        return os_info

    def start_scan(self):
        """Start the vulnerability scan."""
        self.scan_start_time = datetime.now()
        self.vulnerabilities = []

        try:
            # Determine scan depth based on scan type
            if self.scan_type == "quick":
                self._quick_scan()
            elif self.scan_type == "deep":
                self._deep_scan()
            else:  # standard scan
                self._standard_scan()

            self.scan_end_time = datetime.now()
            return self._format_results()

        except Exception as e:
            self.scan_end_time = datetime.now()
            return {
                "status": "failed",
                "error": str(e),
                "scan_type": self.scan_type,
                "start_time": self.scan_start_time.isoformat() if self.scan_start_time else None,
                "end_time": self.scan_end_time.isoformat() if self.scan_end_time else None,
                "duration": str(self.scan_end_time - self.scan_start_time) if self.scan_start_time and self.scan_end_time else None,
                "vulnerabilities": []
            }

    def _quick_scan(self):
        """Perform a quick vulnerability scan."""
        # Check for common configuration issues
        self._check_security_configurations()

        # Check for common service vulnerabilities
        self._check_service_vulnerabilities(ports=[21, 22, 23, 25, 80, 443, 445, 3389])

        # Check for OS vulnerabilities
        self._check_os_vulnerabilities()

    def _standard_scan(self):
        """Perform a standard vulnerability scan."""
        # Run quick scan checks
        self._quick_scan()

        # Check for additional service vulnerabilities
        self._check_service_vulnerabilities(ports=range(1, 1025))

        # Check for network configuration issues
        self._check_network_configurations()

        # Check for web vulnerabilities if web server is running
        self._check_web_vulnerabilities()

    def _deep_scan(self):
        """Perform a deep vulnerability scan."""
        # Run standard scan checks
        self._standard_scan()

        # Check for additional service vulnerabilities on high ports
        self._check_service_vulnerabilities(ports=range(1025, 10000))

        # Check for file system vulnerabilities
        self._check_file_system_vulnerabilities()

        # Check for registry vulnerabilities (Windows only)
        if self.os_info['os_name'].lower() == 'windows':
            self._check_registry_vulnerabilities()

    def _check_security_configurations(self):
        """Check for security configuration vulnerabilities."""
        # Check Windows-specific configurations
        if self.os_info['os_name'].lower() == 'windows':
            # Check UAC status
            try:
                import winreg
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System") as key:
                    uac_enabled = winreg.QueryValueEx(key, "EnableLUA")[0]
                    if uac_enabled == 0:
                        self._add_vulnerability(
                            title="User Account Control (UAC) Disabled",
                            description="User Account Control (UAC) is disabled, which reduces the security of the system.",
                            severity=SEVERITY_MEDIUM,
                            affected_component="Windows Security Configuration",
                            remediation="Enable User Account Control (UAC) in the Control Panel."
                        )
            except:
                pass

            # Check Windows Defender status
            try:
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows Defender\Real-Time Protection") as key:
                    rtm_enabled = winreg.QueryValueEx(key, "DisableRealtimeMonitoring")[0]
                    if rtm_enabled == 1:
                        self._add_vulnerability(
                            title="Windows Defender Real-time Protection Disabled",
                            description="Windows Defender real-time protection is disabled, leaving the system vulnerable to malware.",
                            severity=SEVERITY_HIGH,
                            affected_component="Windows Defender",
                            remediation="Enable Windows Defender real-time protection in Windows Security settings."
                        )
            except:
                pass

            # Check Windows Update status
            try:
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update") as key:
                    au_enabled = winreg.QueryValueEx(key, "AUOptions")[0]
                    if au_enabled == 1:  # 1 means disabled
                        self._add_vulnerability(
                            title="Automatic Updates Disabled",
                            description="Automatic updates are disabled, preventing the system from receiving security patches.",
                            severity=SEVERITY_MEDIUM,
                            affected_component="Windows Update",
                            remediation="Enable automatic updates in Windows Update settings."
                        )
            except:
                pass

    def _check_service_vulnerabilities(self, ports):
        """Check for service vulnerabilities on specified ports."""
        for port in ports:
            try:
                # Create socket and attempt to connect
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(0.5)
                result = s.connect_ex(('127.0.0.1', port))

                if result == 0:
                    # Port is open, try to identify service
                    service_banner = self._get_service_banner(port)

                    # Check for known vulnerabilities in this service
                    self._check_service_vulnerability(port, service_banner)

                s.close()
            except:
                continue

    def _get_service_banner(self, port):
        """Get service banner from a specific port."""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(2.0)
            s.connect(('127.0.0.1', port))

            # Send request based on common protocols
            if port == 80 or port == 8080:
                s.send(b"GET / HTTP/1.1\r\nHost: localhost\r\n\r\n")
            elif port == 21:
                pass  # FTP servers usually send banner automatically
            elif port == 22:
                pass  # SSH servers usually send banner automatically
            elif port == 25 or port == 587:
                pass  # SMTP servers usually send banner automatically
            else:
                # For unknown services, try sending a newline
                s.send(b"\r\n")

            # Receive response
            banner = s.recv(1024)
            s.close()

            # Decode and clean banner
            banner_str = banner.decode('utf-8', errors='ignore').strip()
            return banner_str
        except:
            # Common services by port
            common_ports = {
                21: 'FTP',
                22: 'SSH',
                23: 'Telnet',
                25: 'SMTP',
                53: 'DNS',
                80: 'HTTP',
                110: 'POP3',
                143: 'IMAP',
                443: 'HTTPS',
                445: 'SMB',
                3306: 'MySQL',
                3389: 'RDP',
                5432: 'PostgreSQL',
                8080: 'HTTP-Proxy'
            }

            return common_ports.get(port, "Unknown")

    def _check_service_vulnerability(self, port, service_banner):
        """Check for vulnerabilities in a specific service."""
        service_name = service_banner.split(':')[0] if ':' in service_banner else service_banner
        service_name = service_name.lower()

        # Check for known vulnerabilities in this service
        for vuln_id, vuln_info in self.vuln_db['service_vulns'].items():
            # Check if this vulnerability applies to this service
            if any(s.lower() in service_name for s in vuln_info.get('affected_services', [])):
                # Check version if available
                if 'version_pattern' in vuln_info:
                    version_match = re.search(vuln_info['version_pattern'], service_banner)
                    if not version_match:
                        continue

                # Add vulnerability
                self._add_vulnerability(
                    title=vuln_info['title'],
                    description=vuln_info['description'],
                    severity=vuln_info['severity'],
                    cve_id=vuln_info.get('cve_id'),
                    affected_component=f"{service_name} on port {port}",
                    remediation=vuln_info['remediation']
                )

    def _check_os_vulnerabilities(self):
        """Check for OS vulnerabilities."""
        os_name = self.os_info['os_name'].lower()

        # For Windows, include product name in the check
        if os_name == 'windows' and 'product_name' in self.os_info:
            os_name = self.os_info['product_name'].lower()

        for vuln_id, vuln_info in self.vuln_db['os_vulns'].items():
            # Check if this vulnerability applies to this OS
            if any(os.lower() in os_name for os in vuln_info.get('affected_os', [])):
                # Check specific versions if available
                if 'affected_versions' in vuln_info:
                    if not any(ver.lower() in os_name for ver in vuln_info['affected_versions']):
                        continue

                # Add vulnerability
                self._add_vulnerability(
                    title=vuln_info['title'],
                    description=vuln_info['description'],
                    severity=vuln_info['severity'],
                    cve_id=vuln_info.get('cve_id'),
                    affected_component=self.os_info.get('product_name', self.os_info['os_name']),
                    remediation=vuln_info['remediation']
                )

    def _check_network_configurations(self):
        """Check for network configuration vulnerabilities."""
        # Check if SMBv1 is enabled (Windows only)
        if self.os_info['os_name'].lower() == 'windows':
            try:
                import winreg
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters") as key:
                    try:
                        smb1_enabled = winreg.QueryValueEx(key, "SMB1")[0]
                        if smb1_enabled == 1:
                            self._add_vulnerability(
                                title="SMB Protocol Version 1 Enabled",
                                description="SMB protocol version 1 is enabled. SMBv1 has multiple known security vulnerabilities and has been deprecated.",
                                severity=SEVERITY_HIGH,
                                affected_component="SMB Protocol",
                                remediation="Disable SMBv1 and use SMBv2 or SMBv3 instead. This can be done through Group Policy or Registry settings."
                            )
                    except:
                        # If key doesn't exist, SMBv1 is enabled by default on older Windows versions
                        if 'windows 7' in self.os_info.get('product_name', '').lower() or 'windows server 2008' in self.os_info.get('product_name', '').lower():
                            self._add_vulnerability(
                                title="SMB Protocol Version 1 Enabled (Default)",
                                description="SMB protocol version 1 is enabled by default on this version of Windows. SMBv1 has multiple known security vulnerabilities and has been deprecated.",
                                severity=SEVERITY_HIGH,
                                affected_component="SMB Protocol",
                                remediation="Disable SMBv1 and use SMBv2 or SMBv3 instead. This can be done through Group Policy or Registry settings."
                            )
            except:
                pass

    def _check_web_vulnerabilities(self):
        """Check for web vulnerabilities if a web server is running."""
        # Check if web server is running on common ports
        web_ports = [80, 443, 8080, 8443]
        for port in web_ports:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(0.5)
                result = s.connect_ex(('127.0.0.1', port))
                s.close()

                if result == 0:
                    # Web server is running, check for common vulnerabilities
                    self._check_web_server_vulnerabilities(port)
            except:
                continue

    def _check_web_server_vulnerabilities(self, port):
        """Check for vulnerabilities in a web server."""
        # This is a simplified version - in a real implementation,
        # you would use more sophisticated techniques

        # Determine protocol (HTTP or HTTPS)
        protocol = 'https' if port == 443 or port == 8443 else 'http'
        url = f"{protocol}://localhost:{port}"

        # Check for common sensitive files
        sensitive_files = ['/robots.txt', '/sitemap.xml', '/.git/', '/.env', '/wp-config.php', '/config.php']

        for file_path in sensitive_files:
            try:
                # Use socket to check for file existence
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2.0)
                s.connect(('127.0.0.1', port))

                # Send HTTP request
                request = f"GET {file_path} HTTP/1.1\r\nHost: localhost\r\n\r\n"
                s.send(request.encode())

                # Receive response
                response = s.recv(4096)
                s.close()

                # Check if file exists (HTTP 200 OK)
                if b"HTTP/1.1 200" in response or b"HTTP/1.0 200" in response:
                    self._add_vulnerability(
                        title=f"Sensitive File Exposed: {file_path}",
                        description=f"The web server is exposing a potentially sensitive file at {url + file_path}",
                        severity=SEVERITY_MEDIUM,
                        affected_component=f"Web server on port {port}",
                        remediation=f"Remove or restrict access to the sensitive file {file_path}."
                    )
            except:
                continue

    def _check_file_system_vulnerabilities(self):
        """Check for file system vulnerabilities."""
        # Check for world-writable directories in system paths
        if self.os_info['os_name'].lower() != 'windows':
            # This is Linux/Unix specific
            system_paths = ['/bin', '/sbin', '/usr/bin', '/usr/sbin', '/etc']
            for path in system_paths:
                if os.path.exists(path) and os.access(path, os.W_OK) and not os.access(path, os.O_RDONLY):
                    self._add_vulnerability(
                        title=f"World-Writable System Directory: {path}",
                        description=f"The system directory {path} is writable by the current user, which could allow for privilege escalation.",
                        severity=SEVERITY_HIGH,
                        affected_component="File System Permissions",
                        remediation=f"Correct the permissions on {path} to prevent unauthorized modifications."
                    )

    def _check_registry_vulnerabilities(self):
        """Check for registry vulnerabilities (Windows only)."""
        if self.os_info['os_name'].lower() == 'windows':
            try:
                import winreg

                # Check for AlwaysInstallElevated
                try:
                    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Policies\Microsoft\Windows\Installer") as key:
                        always_install_elevated = winreg.QueryValueEx(key, "AlwaysInstallElevated")[0]
                        if always_install_elevated == 1:
                            self._add_vulnerability(
                                title="AlwaysInstallElevated Registry Key Enabled",
                                description="The AlwaysInstallElevated registry key is enabled, which could allow for privilege escalation through MSI installer packages.",
                                severity=SEVERITY_HIGH,
                                affected_component="Windows Registry",
                                remediation="Disable the AlwaysInstallElevated registry key."
                            )
                except:
                    pass
            except:
                pass

    def _add_vulnerability(self, title, description, severity, affected_component, remediation, cve_id=None):
        """Add a vulnerability to the results."""
        self.vulnerabilities.append({
            "title": title,
            "description": description,
            "severity": severity,
            "cve_id": cve_id,
            "affected_component": affected_component,
            "remediation_steps": remediation,
            "status": STATUS_OPEN
        })

    def _format_results(self):
        """Format the scan results."""
        # Count vulnerabilities by severity
        severity_counts = {
            SEVERITY_CRITICAL: 0,
            SEVERITY_HIGH: 0,
            SEVERITY_MEDIUM: 0,
            SEVERITY_LOW: 0
        }

        for vuln in self.vulnerabilities:
            severity_counts[vuln['severity']] = severity_counts.get(vuln['severity'], 0) + 1

        return {
            "status": "completed",
            "scan_type": self.scan_type,
            "start_time": self.scan_start_time.isoformat() if self.scan_start_time else None,
            "end_time": self.scan_end_time.isoformat() if self.scan_end_time else None,
            "duration": str(self.scan_end_time - self.scan_start_time) if self.scan_start_time and self.scan_end_time else None,
            "total_vulnerabilities": len(self.vulnerabilities),
            "severity_counts": severity_counts,
            "vulnerabilities": self.vulnerabilities
        }


def run_vulnerability_scan(scan_type="standard"):
    """Run a vulnerability scan and return the results as JSON."""
    print(f"[DEBUG] Starting vulnerability scan with type: {scan_type}")

    try:
        scanner = VulnerabilityScanner(scan_type=scan_type)
        print(f"[DEBUG] Scanner initialized successfully")

        print(f"[DEBUG] Running vulnerability scan...")
        results = scanner.start_scan()
        print(f"[DEBUG] Scan completed successfully")

        print(f"[DEBUG] Converting results to JSON...")
        json_results = json.dumps(results, indent=2)
        print(f"[DEBUG] JSON conversion successful, length: {len(json_results)}")

        return json_results
    except Exception as e:
        print(f"[ERROR] Error in run_vulnerability_scan: {str(e)}")
        error_result = {
            "status": "failed",
            "error": str(e),
            "scan_type": scan_type
        }
        return json.dumps(error_result, indent=2)


if __name__ == "__main__":
    # If run directly, perform a scan and print the results
    scan_type = "standard"
    if len(sys.argv) > 1:
        scan_type = sys.argv[1]

    print(run_vulnerability_scan(scan_type))
