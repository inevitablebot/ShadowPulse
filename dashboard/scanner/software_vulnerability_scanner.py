"""
Software Vulnerability Scanner Module

This module provides functionality to scan installed software for vulnerabilities
using various vulnerability databases.
"""

import requests
import json
import logging
import time
import re
import threading
from datetime import datetime, timedelta
from django.utils import timezone
from .models import InstalledSoftware, SoftwareVulnerabilityScan, SoftwareVulnerability, Target, NetworkAlert
from .state_manager import register_process, update_process_data, unregister_process, is_thread_alive

# Configure logging
logger = logging.getLogger(__name__)

# Global registry for active scanners
_active_scanners = {}

class SoftwareVulnerabilityScanner:
    """Class for scanning installed software for vulnerabilities"""

    def __init__(self, target_id, scan_id=None):
        """Initialize the scanner with a target ID"""
        self.target_id = target_id
        self.scan_id = scan_id
        self.target = Target.objects.get(id=target_id)
        self.running = False
        self.progress = 0
        self.status_message = "Initializing..."
        self.vulnerabilities = []

        # API configuration
        self.nvd_api_key = None  # Optional: Add your NVD API key here
        self.vulners_api_key = None  # Optional: Add your Vulners API key here

        # Cache for vulnerability lookups
        self._vulnerability_cache = {}

    def start_scan(self, process_id=None):
        """Start the vulnerability scan in a separate thread"""
        if self.running:
            logger.warning(f"Scan already running for target {self.target.id}")
            return False

        self.running = True
        self.progress = 0
        self.status_message = "Starting scan..."
        self.vulnerabilities = []

        logger.info(f"Starting vulnerability scan for target {self.target.id}")

        # Create a new scan record if not provided
        if not self.scan_id:
            scan = SoftwareVulnerabilityScan.objects.create(
                target=self.target,
                status='in_progress',
                start_time=timezone.now()
            )
            self.scan_id = scan.id
            logger.info(f"Created new scan record with ID {self.scan_id}")
        else:
            try:
                scan = SoftwareVulnerabilityScan.objects.get(id=self.scan_id)
                scan.status = 'in_progress'
                scan.start_time = timezone.now()
                scan.save()
                logger.info(f"Updated existing scan record with ID {self.scan_id}")
            except SoftwareVulnerabilityScan.DoesNotExist:
                logger.error(f"Scan record with ID {self.scan_id} not found")
                self.running = False
                return False

        # Register with state manager if process_id provided
        if process_id:
            logger.info(f"Registering process {process_id} with state manager")
            register_process(process_id, {
                'progress': 0,
                'status_message': 'Starting software vulnerability scan...',
                'scan_id': self.scan_id
            })

        # Store scanner in registry
        _active_scanners[self.scan_id] = self
        logger.info(f"Stored scanner in registry with ID {self.scan_id}")

        # Start scan in a separate thread
        thread = threading.Thread(target=self._run_scan, args=(process_id,))
        thread.daemon = True
        thread.start()
        logger.info(f"Started scan thread for scan ID {self.scan_id}")

        return True

    def stop_scan(self):
        """Stop the running scan"""
        self.running = False

        # Update scan status
        try:
            scan = SoftwareVulnerabilityScan.objects.get(id=self.scan_id)
            scan.status = 'cancelled'
            scan.end_time = timezone.now()
            scan.save()
        except SoftwareVulnerabilityScan.DoesNotExist:
            pass

        return True

    def get_status(self):
        """Get the current status of the scan"""
        try:
            scan = SoftwareVulnerabilityScan.objects.get(id=self.scan_id)
            completed = scan.status == 'completed'
            failed = scan.status == 'failed'
        except SoftwareVulnerabilityScan.DoesNotExist:
            completed = False
            failed = False

        return {
            'running': self.running,
            'progress': self.progress,
            'status_message': self.status_message,
            'vulnerabilities_found': len(self.vulnerabilities),
            'completed': completed,
            'failed': failed,
            'scan_id': self.scan_id
        }

    def _run_scan(self, process_id=None):
        """Run the vulnerability scan"""
        from .state_manager import update_process_data

        try:
            # Get installed software for the target
            logger.info(f"Getting installed software for target {self.target.id}")
            installed_software = self._get_installed_software()

            if not installed_software:
                logger.warning(f"No installed software found for target {self.target.id}")
                self.status_message = "No installed software found for this target."
                self.progress = 100
                self._finalize_scan('completed', process_id)
                return

            total_software = len(installed_software)
            logger.info(f"Found {total_software} software items for target {self.target.id}")

            # Update scan record with total software count
            scan = SoftwareVulnerabilityScan.objects.get(id=self.scan_id)
            scan.total_software = total_software
            scan.save()
            logger.info(f"Updated scan record with total software count: {total_software}")

            # Update state manager
            if process_id:
                update_process_data(process_id, {
                    'progress': self.progress,
                    'status_message': f"Found {total_software} software items to scan",
                    'total_software': total_software
                })

            # Scan each software for vulnerabilities
            for i, software in enumerate(installed_software):
                if not self.running:
                    logger.info("Scan was stopped. Exiting.")
                    break

                # Update progress - use a slower progression to show more activity
                # Only go up to 90% during scanning, save the last 10% for finalizing
                self.progress = int((i / total_software) * 90)
                self.status_message = f"Scanning {software.name} {software.version or ''} for vulnerabilities ({i+1}/{total_software})..."
                logger.info(f"Progress: {self.progress}% - {self.status_message}")

                # Update state manager
                if process_id:
                    update_process_data(process_id, {
                        'progress': self.progress,
                        'status_message': self.status_message,
                        'software_scanned': i + 1,
                        'total_software': total_software
                    })

                # Check for vulnerabilities
                self._check_software_vulnerabilities(software)

                # Add a longer delay between software items to make the progress more visible
                # and to avoid rate limiting on the APIs
                time.sleep(2)  # Increased from 1 to 2 seconds

            # Update progress to 95% during finalization
            self.progress = 95
            self.status_message = "Finalizing scan results..."
            logger.info(f"Progress: {self.progress}% - {self.status_message}")

            if process_id:
                update_process_data(process_id, {
                    'progress': self.progress,
                    'status_message': self.status_message
                })

            # Add a small delay to show the finalization step
            time.sleep(2)

            # Finalize scan
            self._finalize_scan('completed', process_id)

        except Exception as e:
            logger.error(f"Error in software vulnerability scan: {str(e)}", exc_info=True)
            self.status_message = f"Scan failed: {str(e)}"
            self._finalize_scan('failed', process_id, error=str(e))

    def _finalize_scan(self, status, process_id=None, error=None):
        """Finalize the scan and update records"""
        self.running = False
        self.progress = 100

        # Log error if provided
        if error:
            logger.error(f"Scan finalized with error: {error}")

        try:
            # Update scan record
            scan = SoftwareVulnerabilityScan.objects.get(id=self.scan_id)
            scan.status = status
            scan.end_time = timezone.now()

            # Count vulnerabilities by severity
            high_count = 0
            medium_count = 0
            low_count = 0
            vulnerable_software_ids = set()

            for vuln in self.vulnerabilities:
                if vuln.severity == 'critical' or vuln.severity == 'high':
                    high_count += 1
                elif vuln.severity == 'medium':
                    medium_count += 1
                else:
                    low_count += 1

                vulnerable_software_ids.add(vuln.software.id)

            scan.high_vulnerabilities = high_count
            scan.medium_vulnerabilities = medium_count
            scan.low_vulnerabilities = low_count
            scan.total_vulnerabilities = len(self.vulnerabilities)
            scan.vulnerable_software = len(vulnerable_software_ids)
            scan.save()

            # Create network alerts for high severity vulnerabilities
            if high_count > 0:
                alert_description = f"Found {high_count} high severity vulnerabilities in installed software."
                NetworkAlert.objects.create(
                    alert_type="software_vulnerability",
                    description=alert_description,
                    severity="high",
                    source_ip=self.target.ip_address,
                    packet_info=json.dumps({
                        "scan_id": self.scan_id,
                        "vulnerabilities": high_count
                    })
                )

            # Update state manager
            if process_id:
                update_process_data(process_id, {
                    'progress': 100,
                    'status_message': f"Scan completed. Found {len(self.vulnerabilities)} vulnerabilities.",
                    'vulnerabilities_found': len(self.vulnerabilities),
                    'completed': True,
                    'scan_id': self.scan_id
                })

                # Unregister process after a delay
                def delayed_unregister():
                    time.sleep(60)  # Keep data available for 1 minute
                    unregister_process(process_id)

                threading.Thread(target=delayed_unregister, daemon=True).start()

        except Exception as e:
            logger.error(f"Error finalizing scan: {str(e)}", exc_info=True)
            if process_id:
                update_process_data(process_id, {
                    'progress': 100,
                    'status_message': f"Error finalizing scan: {str(e)}",
                    'failed': True,
                    'error': str(e)
                })

    def _get_installed_software(self):
        """Get installed software for the target"""
        # Check if we already have software records for this target
        existing_software = InstalledSoftware.objects.filter(target=self.target)

        if existing_software.exists():
            self.status_message = "Using existing software list..."
            return list(existing_software)

        # Otherwise, extract software from OS info
        self.status_message = "Extracting installed software from OS info..."
        software_list = self._extract_software_from_os_info()

        # Save software to database
        saved_software = []
        for sw in software_list:
            software, _ = InstalledSoftware.objects.update_or_create(
                target=self.target,
                name=sw['name'],
                version=sw.get('version'),
                defaults={
                    'vendor': sw.get('vendor'),
                    'install_date': sw.get('install_date'),
                    'install_location': sw.get('install_location'),
                    'last_checked': timezone.now()
                }
            )
            saved_software.append(software)

        return saved_software

    def _extract_software_from_os_info(self):
        """Extract installed software from OS info"""
        # Get the latest OS info scan result
        from .models import ScanResult

        try:
            # First, check for a dedicated installed software scan
            installed_software_scan = ScanResult.objects.filter(
                target=self.target,
                scan_type__contains="Installed Software"
            ).order_by('-scan_time').first()

            if installed_software_scan:
                logger.info(f"Found dedicated installed software scan (ID: {installed_software_scan.id})")
                result_data = installed_software_scan.result_data

                # Check if it's Windows or Linux
                if "Installed Programs" in result_data or "Name" in result_data:
                    # Windows format
                    return self._parse_windows_installed_software(result_data)
                elif "dpkg -l" in result_data or "rpm -qa" in result_data:
                    # Linux format
                    return self._parse_linux_installed_software(result_data)

            # If no dedicated scan found, try to find it in OS info
            logger.info("No dedicated installed software scan found, checking OS info scans")
            os_info_scan = ScanResult.objects.filter(
                target=self.target,
                scan_type__contains="OS Info"
            ).order_by('-scan_time').first()

            if not os_info_scan:
                logger.warning(f"No OS info scan found for target {self.target}")
                return []

            # Parse the OS info result
            result_data = os_info_scan.result_data
            logger.info(f"Using OS info scan (ID: {os_info_scan.id})")

            # Check if it's Windows or Linux
            if "Installed Programs" in result_data:
                # Windows format
                return self._parse_windows_installed_software(result_data)
            elif "dpkg -l" in result_data or "rpm -qa" in result_data:
                # Linux format
                return self._parse_linux_installed_software(result_data)
            else:
                logger.warning(f"Unknown OS info format for target {self.target}")
                return []

        except Exception as e:
            logger.error(f"Error extracting software from OS info: {str(e)}", exc_info=True)
            return []

    def _parse_windows_installed_software(self, os_info):
        """Parse installed software from Windows OS info"""
        software_list = []
        logger.info("Parsing Windows installed software")

        # Find the Installed Programs section
        match = re.search(r"Installed Programs:(.*?)(?:\n\n|\Z)", os_info, re.DOTALL)
        if not match:
            logger.warning("No 'Installed Programs:' section found in OS info")

            # Try alternative format (table format)
            if "Name" in os_info and "Version" in os_info:
                logger.info("Trying to parse table format")
                lines = os_info.split('\n')
                header_line = None

                # Find the header line
                for i, line in enumerate(lines):
                    if "Name" in line and "Version" in line:
                        header_line = i
                        break

                if header_line is not None:
                    # Skip header and separator lines
                    for line in lines[header_line+2:]:
                        line = line.strip()
                        if not line:
                            continue

                        # Try to parse the line based on spaces
                        parts = re.split(r'\s{2,}', line)
                        if len(parts) >= 2:
                            name = parts[0].strip()
                            version = parts[1].strip() if len(parts) > 1 else None

                            # Skip empty names or Windows components
                            if not name or name.lower() in ['windows', 'microsoft windows']:
                                continue

                            software = {
                                'name': name,
                                'version': version
                            }

                            if len(parts) > 2:
                                software['vendor'] = parts[2].strip()

                            software_list.append(software)

            return software_list

        programs_section = match.group(1).strip()
        logger.info(f"Found programs section with {len(programs_section)} characters")

        # Parse each line
        for line in programs_section.split('\n'):
            line = line.strip()
            if not line or line.startswith('Name') or line.startswith('----'):
                continue

            # Try to parse the line
            parts = line.split('|')
            if len(parts) >= 2:
                name = parts[0].strip()
                version = parts[1].strip() if len(parts) > 1 else None

                # Skip empty names or Windows components
                if not name or name.lower() in ['windows', 'microsoft windows']:
                    continue

                software = {
                    'name': name,
                    'version': version
                }

                if len(parts) > 2:
                    software['vendor'] = parts[2].strip()

                if len(parts) > 3:
                    install_date_str = parts[3].strip()
                    try:
                        # Try to parse the date
                        software['install_date'] = datetime.strptime(install_date_str, '%Y-%m-%d').date()
                    except:
                        pass

                software_list.append(software)

        # If we didn't find any software with the pipe delimiter, try space delimiter
        if not software_list:
            logger.info("No software found with pipe delimiter, trying space delimiter")
            for line in programs_section.split('\n'):
                line = line.strip()
                if not line or line.startswith('Name') or line.startswith('----'):
                    continue

                # Try to parse the line based on spaces
                parts = re.split(r'\s{2,}', line)
                if len(parts) >= 2:
                    name = parts[0].strip()
                    version = parts[1].strip() if len(parts) > 1 else None

                    # Skip empty names or Windows components
                    if not name or name.lower() in ['windows', 'microsoft windows']:
                        continue

                    software = {
                        'name': name,
                        'version': version
                    }

                    if len(parts) > 2:
                        software['vendor'] = parts[2].strip()

                    software_list.append(software)

        return software_list

    def _parse_linux_installed_software(self, os_info):
        """Parse installed software from Linux OS info"""
        software_list = []

        # Check for dpkg output (Debian/Ubuntu)
        dpkg_match = re.search(r"dpkg -l:(.*?)(?:\n\n|\Z)", os_info, re.DOTALL)
        if dpkg_match:
            dpkg_section = dpkg_match.group(1).strip()

            # Parse each line
            for line in dpkg_section.split('\n'):
                line = line.strip()
                if not line or line.startswith('Desired') or line.startswith('ii') == False:
                    continue

                # Parse dpkg format: ii package version description
                parts = line.split()
                if len(parts) >= 3:
                    name = parts[1]
                    version = parts[2]

                    software_list.append({
                        'name': name,
                        'version': version
                    })

        # Check for rpm output (RHEL/CentOS/Fedora)
        rpm_match = re.search(r"rpm -qa:(.*?)(?:\n\n|\Z)", os_info, re.DOTALL)
        if rpm_match:
            rpm_section = rpm_match.group(1).strip()

            # Parse each line
            for line in rpm_section.split('\n'):
                line = line.strip()
                if not line:
                    continue

                # Parse rpm format: name-version-release.arch
                # Extract name and version
                match = re.match(r"([^-]+)-([^-]+)", line)
                if match:
                    name = match.group(1)
                    version = match.group(2)

                    software_list.append({
                        'name': name,
                        'version': version
                    })

        return software_list

    def _check_software_vulnerabilities(self, software):
        """Check for vulnerabilities for a specific software"""
        if not software.name:
            logger.warning(f"Skipping software with no name")
            return

        logger.info(f"Checking vulnerabilities for {software.name} {software.version or 'unknown version'}")

        # Create cache key
        cache_key = f"{software.name}:{software.version or 'none'}"

        # Check cache first
        if cache_key in self._vulnerability_cache:
            logger.info(f"Using cached vulnerabilities for {cache_key}")
            vulnerabilities = self._vulnerability_cache[cache_key]
        else:
            # Try different APIs for vulnerability information
            vulnerabilities = []

            # Try OSV API first for all software
            logger.info(f"Checking OSV API for {software.name}")
            osv_vulns = self._check_osv_api(software.name, software.version)
            if osv_vulns:
                logger.info(f"Found {len(osv_vulns)} vulnerabilities from OSV API for {software.name}")
                vulnerabilities.extend(osv_vulns)
            else:
                logger.info(f"No vulnerabilities found from OSV API for {software.name}")

            # If no vulnerabilities found, try Vulners API
            if not vulnerabilities:
                logger.info(f"Checking Vulners API for {software.name}")
                vulners_vulns = self._check_vulners_api(software.name, software.version)
                if vulners_vulns:
                    logger.info(f"Found {len(vulners_vulns)} vulnerabilities from Vulners API for {software.name}")
                    vulnerabilities.extend(vulners_vulns)
                else:
                    logger.info(f"No vulnerabilities found from Vulners API for {software.name}")

            # If still no vulnerabilities, try NVD API
            if not vulnerabilities:
                logger.info(f"Checking NVD API for {software.name}")
                nvd_vulns = self._check_nvd_api(software.name, software.version)
                if nvd_vulns:
                    logger.info(f"Found {len(nvd_vulns)} vulnerabilities from NVD API for {software.name}")
                    vulnerabilities.extend(nvd_vulns)
                else:
                    logger.info(f"No vulnerabilities found from NVD API for {software.name}")

            # If still no vulnerabilities, try CIRCL API as last resort
            if not vulnerabilities:
                logger.info(f"Checking CIRCL API for {software.name}")
                circl_vulns = self._check_circl_api(software.name, software.version)
                if circl_vulns:
                    logger.info(f"Found {len(circl_vulns)} vulnerabilities from CIRCL API for {software.name}")
                    vulnerabilities.extend(circl_vulns)
                else:
                    logger.info(f"No vulnerabilities found from CIRCL API for {software.name}")

            # Add some mock vulnerabilities for testing if none found
            if not vulnerabilities and software.name.lower() in ['chrome', 'firefox', 'edge', 'java', 'adobe', 'flash', 'acrobat', 'discord', '.net']:
                logger.info(f"Adding mock vulnerabilities for {software.name} for testing purposes")
                mock_vulns = self._generate_mock_vulnerabilities(software.name, software.version)
                vulnerabilities.extend(mock_vulns)

            # Cache the results
            self._vulnerability_cache[cache_key] = vulnerabilities
            logger.info(f"Cached {len(vulnerabilities)} vulnerabilities for {cache_key}")

        # Save vulnerabilities to database
        vulns_added = 0
        for vuln_data in vulnerabilities:
            # Check if this vulnerability already exists
            vuln_id = vuln_data.get('cve_id', '') or vuln_data.get('id', '')
            existing_vulns = SoftwareVulnerability.objects.filter(
                software=software,
                cve_id=vuln_id
            )

            if existing_vulns.exists():
                # Skip creating duplicate vulnerabilities
                logger.info(f"Skipping existing vulnerability {vuln_id} for {software.name}")
                continue

            # Create vulnerability record
            try:
                vulnerability = SoftwareVulnerability.objects.create(
                    scan_id=self.scan_id,
                    software=software,
                    title=vuln_data.get('title', ''),
                    description=vuln_data.get('description', ''),
                    severity=vuln_data.get('severity', 'unknown'),
                    cve_id=vuln_id,
                    cvss_score=vuln_data.get('cvss_score', 0.0),
                    affected_versions=vuln_data.get('affected_versions', ''),
                    remediation_steps=vuln_data.get('remediation', 'Update to the latest version of the software.')
                )

                vulns_added += 1
                logger.info(f"Added vulnerability {vuln_id} for {software.name}")

                # Mark software as vulnerable
                if not software.is_vulnerable:
                    software.is_vulnerable = True
                    software.save()
                    logger.info(f"Marked {software.name} as vulnerable")

                self.vulnerabilities.append(vulnerability)
            except Exception as e:
                logger.error(f"Error creating vulnerability record: {str(e)}", exc_info=True)

        logger.info(f"Added {vulns_added} new vulnerabilities for {software.name}")

    def _generate_mock_vulnerabilities(self, software_name, software_version):
        """Generate mock vulnerabilities for testing purposes"""
        mock_vulns = []

        # Create a few mock vulnerabilities with different severities
        severities = ['critical', 'high', 'medium', 'low']
        for i in range(1, 5):
            severity = severities[i-1]
            cvss_score = 9.5 if severity == 'critical' else 7.5 if severity == 'high' else 5.5 if severity == 'medium' else 3.5

            mock_vulns.append({
                'cve_id': f"CVE-2023-{1000 + i}",
                'title': f"{software_name} {severity.capitalize()} Vulnerability",
                'description': f"This is a mock {severity} vulnerability for {software_name} {software_version or ''} created for testing purposes.",
                'severity': severity,
                'cvss_score': cvss_score,
                'affected_versions': f"All versions of {software_name}",
                'remediation': "Update to the latest version of the software."
            })

        return mock_vulns

    def _check_osv_api(self, software_name, software_version):
        """Check the OSV API for vulnerabilities in any software"""
        try:
            # Clean up the software name to improve matching
            # Remove common suffixes and prefixes that might interfere with matching
            clean_name = software_name.lower()
            for prefix in ['microsoft', 'ms', 'adobe', 'google', 'mozilla', 'oracle']:
                if clean_name.startswith(prefix + ' '):
                    clean_name = clean_name[len(prefix) + 1:]

            for suffix in ['(x86)', '(x64)', '64-bit', '32-bit', 'x64', 'x86']:
                if clean_name.endswith(' ' + suffix):
                    clean_name = clean_name[:-len(suffix) - 1]

            # Try to determine if this is a known ecosystem
            ecosystem = None

            # Common ecosystems and their package prefixes/names
            ecosystem_mapping = {
                'PyPI': ['python', 'pip', 'pipenv', 'poetry', 'django', 'flask', 'requests', 'numpy', 'pandas'],
                'npm': ['node', 'npm', 'yarn', 'nodejs', 'react', 'angular', 'vue', 'express', 'next'],
                'Maven': ['maven', 'gradle', 'java', 'spring', 'tomcat', 'hibernate', 'apache'],
                'NuGet': ['nuget', '.net', 'dotnet', 'aspnet', 'core', 'entity', 'xamarin'],
                'Go': ['go', 'golang', 'gin', 'echo', 'fiber', 'gorm'],
                'RubyGems': ['ruby', 'gem', 'bundler', 'rails', 'sinatra', 'jekyll'],
                'crates.io': ['rust', 'cargo', 'actix', 'tokio', 'serde'],
                'Packagist': ['php', 'composer', 'laravel', 'symfony', 'wordpress'],
                'Debian': ['debian', 'ubuntu', 'apt', 'dpkg'],
                'Alpine': ['alpine', 'apk'],
                'CRAN': ['r', 'cran', 'rstudio'],
                'Hex': ['elixir', 'phoenix', 'hex'],
                'Pub': ['dart', 'flutter', 'pub'],
                'Conda': ['conda', 'anaconda', 'miniconda']
            }

            # Check if the software name matches any known ecosystem
            for eco, keywords in ecosystem_mapping.items():
                if any(keyword in clean_name for keyword in keywords):
                    ecosystem = eco
                    break

            # Try multiple approaches for better coverage
            vulnerabilities = []

            # 1. First try: Generic query with the original name
            url = "https://api.osv.dev/v1/query"
            payload = {
                "version": software_version or "",
                "package": {
                    "name": software_name
                }
            }

            logger.info(f"Trying OSV API with original name: {software_name}")
            response = requests.post(url, json=payload, timeout=10)

            if response.status_code == 200:
                data = response.json()
                vulns = data.get('vulns', [])
                if vulns:
                    logger.info(f"Found {len(vulns)} vulnerabilities with original name")
                    vulnerabilities.extend(self._parse_osv_vulns(vulns, software_name, software_version))

            # 2. Second try: If we identified an ecosystem, try with that
            if not vulnerabilities and ecosystem:
                logger.info(f"Trying OSV API with ecosystem {ecosystem} for {clean_name}")
                payload = {
                    "version": software_version or "",
                    "package": {
                        "name": clean_name,
                        "ecosystem": ecosystem
                    }
                }

                response = requests.post(url, json=payload, timeout=10)

                if response.status_code == 200:
                    data = response.json()
                    vulns = data.get('vulns', [])
                    if vulns:
                        logger.info(f"Found {len(vulns)} vulnerabilities with ecosystem {ecosystem}")
                        vulnerabilities.extend(self._parse_osv_vulns(vulns, software_name, software_version))

            # 3. Third try: If still no vulnerabilities, try with cleaned name without ecosystem
            if not vulnerabilities and clean_name != software_name:
                logger.info(f"Trying OSV API with cleaned name: {clean_name}")
                payload = {
                    "version": software_version or "",
                    "package": {
                        "name": clean_name
                    }
                }

                response = requests.post(url, json=payload, timeout=10)

                if response.status_code == 200:
                    data = response.json()
                    vulns = data.get('vulns', [])
                    if vulns:
                        logger.info(f"Found {len(vulns)} vulnerabilities with cleaned name")
                        vulnerabilities.extend(self._parse_osv_vulns(vulns, software_name, software_version))

            # 4. Fourth try: Try with just the first word of the software name
            # This can help with packages like "React Native" -> "react"
            if not vulnerabilities and ' ' in clean_name:
                first_word = clean_name.split(' ')[0]
                if len(first_word) > 2:  # Avoid very short words
                    logger.info(f"Trying OSV API with first word: {first_word}")
                    payload = {
                        "version": software_version or "",
                        "package": {
                            "name": first_word
                        }
                    }

                    response = requests.post(url, json=payload, timeout=10)

                    if response.status_code == 200:
                        data = response.json()
                        vulns = data.get('vulns', [])
                        if vulns:
                            logger.info(f"Found {len(vulns)} vulnerabilities with first word")
                            vulnerabilities.extend(self._parse_osv_vulns(vulns, software_name, software_version))

            logger.info(f"Found total of {len(vulnerabilities)} vulnerabilities from OSV API for {software_name}")
            return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking OSV API: {str(e)}", exc_info=True)
            return []

    def _parse_osv_vulns(self, vulns, software_name, software_version):
        """Parse vulnerabilities from OSV API response"""
        vulnerabilities = []

        for vuln in vulns:
            # Get vulnerability ID
            vuln_id = vuln.get('id', '')

            # Get summary/title
            summary = vuln.get('summary', f"{software_name} Vulnerability")

            # Get details/description
            details = vuln.get('details', '')

            # Get severity (OSV doesn't provide CVSS scores directly)
            # We'll use the severity from the references if available
            severity = 'unknown'
            cvss_score = 0.0

            # Check references for CVSS information
            for ref in vuln.get('references', []):
                if 'severity' in ref:
                    severity = ref.get('severity', '').lower()
                if 'cvss' in ref:
                    cvss_score = float(ref.get('cvss', {}).get('score', 0.0))

            # If we still don't have severity, try to determine it from affected versions
            if severity == 'unknown' and vuln.get('affected', []):
                # If there are many affected versions, it's probably more severe
                affected_count = len(vuln.get('affected', []))
                if affected_count > 10:
                    severity = 'high'
                elif affected_count > 5:
                    severity = 'medium'
                else:
                    severity = 'low'

            # Get affected versions
            affected_versions = []
            for affected in vuln.get('affected', []):
                for version_range in affected.get('ranges', []):
                    for event in version_range.get('events', []):
                        affected_versions.append(event.get('introduced', ''))
                        affected_versions.append(event.get('fixed', ''))

            affected_versions_str = ', '.join([v for v in affected_versions if v])

            # Create vulnerability entry
            vulnerability = {
                'id': vuln_id,
                'title': summary,
                'description': details,
                'severity': severity,
                'cvss_score': cvss_score,
                'affected_versions': affected_versions_str,
                'remediation': "Update to the latest version of the software."
            }

            vulnerabilities.append(vulnerability)

        return vulnerabilities

    def _check_vulners_api(self, software_name, software_version):
        """Check the Vulners API for vulnerabilities"""
        try:
            # Construct the API URL
            url = "https://vulners.com/api/v3/burp/software/"

            # Create payload
            payload = {
                "software": software_name,
                "version": software_version or "",
                "apiKey": self.vulners_api_key
            }

            logger.info(f"Sending request to Vulners API for {software_name} {software_version or ''}")

            # Make the request
            response = requests.post(url, json=payload, timeout=10)

            if response.status_code != 200:
                logger.warning(f"Vulners API returned status code {response.status_code}")
                return []

            # Parse the response
            data = response.json()
            vulnerabilities = []

            # Check if the result is OK
            if data.get('result') != 'OK':
                logger.warning(f"Vulners API returned error: {data.get('data', {}).get('error', 'Unknown error')}")
                return []

            # Extract vulnerability information
            vulns = data.get('data', {}).get('search', [])

            for vuln in vulns:
                # Get vulnerability ID
                vuln_id = vuln.get('id', '')

                # Get title
                title = vuln.get('title', f"{software_name} Vulnerability")

                # Get description
                description = vuln.get('description', '')

                # Get CVSS score and severity
                cvss_score = float(vuln.get('cvss', {}).get('score', 0.0))

                # Determine severity based on CVSS score
                if cvss_score >= 9.0:
                    severity = 'critical'
                elif cvss_score >= 7.0:
                    severity = 'high'
                elif cvss_score >= 4.0:
                    severity = 'medium'
                elif cvss_score > 0:
                    severity = 'low'
                else:
                    severity = 'unknown'

                # Create vulnerability entry
                vulnerability = {
                    'id': vuln_id,
                    'title': title,
                    'description': description,
                    'severity': severity,
                    'cvss_score': cvss_score,
                    'affected_versions': f"Affects {software_name} {software_version or ''}",
                    'remediation': "Update to the latest version of the software."
                }

                vulnerabilities.append(vulnerability)

            logger.info(f"Found {len(vulnerabilities)} vulnerabilities from Vulners API for {software_name}")
            return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking Vulners API: {str(e)}", exc_info=True)
            return []

    def _check_nvd_api(self, software_name, software_version):
        """Check the NVD API for vulnerabilities"""
        try:
            # Construct the API URL
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

            # Create search query
            query = f"{software_name}"
            if software_version:
                query += f" {software_version}"

            # Set up parameters
            params = {
                "keywordSearch": query,
                "resultsPerPage": 20
            }

            # Add API key if available
            if self.nvd_api_key:
                params["apiKey"] = self.nvd_api_key

            # Make the request
            response = requests.get(base_url, params=params, timeout=10)

            if response.status_code != 200:
                logger.warning(f"NVD API returned status code {response.status_code}")
                return []

            # Parse the response
            data = response.json()
            vulnerabilities = []

            # Extract vulnerability information
            for vuln in data.get('vulnerabilities', []):
                cve = vuln.get('cve', {})

                # Get CVE ID
                cve_id = cve.get('id')

                # Get description
                descriptions = cve.get('descriptions', [])
                description = next((d.get('value') for d in descriptions if d.get('lang') == 'en'), '')

                # Get metrics
                metrics = cve.get('metrics', {})
                cvss_data = metrics.get('cvssMetricV31', [{}])[0] if 'cvssMetricV31' in metrics else \
                           metrics.get('cvssMetricV30', [{}])[0] if 'cvssMetricV30' in metrics else \
                           metrics.get('cvssMetricV2', [{}])[0] if 'cvssMetricV2' in metrics else {}

                cvss_score = 0.0
                severity = 'unknown'

                if cvss_data:
                    cvss = cvss_data.get('cvssData', {})
                    cvss_score = cvss.get('baseScore', 0.0)

                    # Determine severity based on CVSS score
                    if cvss_score >= 9.0:
                        severity = 'critical'
                    elif cvss_score >= 7.0:
                        severity = 'high'
                    elif cvss_score >= 4.0:
                        severity = 'medium'
                    elif cvss_score > 0:
                        severity = 'low'

                # Create vulnerability entry
                vulnerability = {
                    'cve_id': cve_id,
                    'title': f"{software_name} - {cve_id}",
                    'description': description,
                    'severity': severity,
                    'cvss_score': cvss_score,
                    'remediation': "Update to the latest version of the software."
                }

                vulnerabilities.append(vulnerability)

            return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking NVD API: {str(e)}", exc_info=True)
            return []

    def _check_circl_api(self, software_name, software_version):
        """Check the CIRCL API for vulnerabilities"""
        try:
            # Construct the API URL
            base_url = f"https://cve.circl.lu/api/search/{software_name}"

            # Make the request
            response = requests.get(base_url, timeout=10)

            if response.status_code != 200:
                logger.warning(f"CIRCL API returned status code {response.status_code}")
                return []

            # Parse the response
            data = response.json()
            vulnerabilities = []

            # Extract vulnerability information
            for vuln in data.get('results', []):
                # Check if the version is affected
                if software_version and not self._is_version_affected(software_version, vuln):
                    continue

                # Get CVE ID
                cve_id = vuln.get('id')

                # Get description
                description = vuln.get('summary', '')

                # Get CVSS score and severity
                cvss_score = vuln.get('cvss', 0.0)

                # Determine severity based on CVSS score
                if cvss_score >= 9.0:
                    severity = 'critical'
                elif cvss_score >= 7.0:
                    severity = 'high'
                elif cvss_score >= 4.0:
                    severity = 'medium'
                elif cvss_score > 0:
                    severity = 'low'
                else:
                    severity = 'unknown'

                # Create vulnerability entry
                vulnerability = {
                    'cve_id': cve_id,
                    'title': f"{software_name} - {cve_id}",
                    'description': description,
                    'severity': severity,
                    'cvss_score': cvss_score,
                    'remediation': "Update to the latest version of the software."
                }

                vulnerabilities.append(vulnerability)

            return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking CIRCL API: {str(e)}", exc_info=True)
            return []

    def _is_version_affected(self, version, vuln_data):
        """Check if a specific version is affected by a vulnerability"""
        # This is a simplified version check
        # In a real implementation, you would need to parse CPE strings and version ranges

        # Check if the version appears in the vulnerability data
        if 'vulnerable_configuration' in vuln_data:
            for config in vuln_data['vulnerable_configuration']:
                if version in config:
                    return True

        return False


# Helper functions for managing scanners
def create_software_vuln_scanner(target_id, scan_id=None):
    """Create a new software vulnerability scanner"""
    scanner = SoftwareVulnerabilityScanner(target_id, scan_id)
    if scan_id:
        _active_scanners[scan_id] = scanner
    return scanner

def get_software_vuln_scanner(scan_id):
    """Get an existing software vulnerability scanner"""
    return _active_scanners.get(scan_id)

def remove_software_vuln_scanner(scan_id):
    """Remove a software vulnerability scanner from the registry"""
    if scan_id in _active_scanners:
        del _active_scanners[scan_id]
        return True
    return False
