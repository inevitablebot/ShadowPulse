"""
Port-based Vulnerability Scanner

This module provides functionality to scan for vulnerabilities based on open ports
and detected services from port scan results. It uses various APIs to match services
and versions to known vulnerabilities (CVEs).
"""

import requests
import json
import logging
import re
import time
import threading
from django.utils import timezone
from .models import PortScanResult, PortInfo, Vulnerability

# Configure logging
logger = logging.getLogger(__name__)

# API endpoints
NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
CIRCL_API_URL = "https://cve.circl.lu/api"

class PortVulnerabilityScanner:
    """
    Scanner for identifying vulnerabilities based on port scan results.
    """

    def __init__(self, scan_result):
        """
        Initialize the vulnerability scanner.

        Args:
            scan_result (PortScanResult): The port scan result to analyze
        """
        self.scan_result = scan_result
        self.target = scan_result.target
        self.port_info = scan_result.port_info.filter(is_open=True)
        self.vulnerabilities = []
        self.progress = 0
        self.status_message = "Initializing vulnerability scan..."
        self.running = False
        self.scan_thread = None

    def start_scan(self):
        """Start the vulnerability scanning process."""
        if self.running:
            return False

        self.running = True
        self.progress = 0
        self.status_message = "Starting vulnerability scan..."

        # Update scan result to indicate vulnerability scanning
        self.scan_result.notes = (self.scan_result.notes or "") + "\nVulnerability scanning started."
        self.scan_result.save()

        # Register with state manager
        from . import state_manager
        process_id = f"port_vuln_scan_{self.scan_result.id}"
        state_manager.register_process(process_id, 'port_vuln_scan', {
            'scan_id': self.scan_result.id,
            'target_id': str(self.target.id)
        })

        # Start scan thread
        self.scan_thread = threading.Thread(target=self._run_scan)
        self.scan_thread.daemon = True
        self.scan_thread.start()

        # Register thread with state manager
        state_manager.register_thread(process_id, self.scan_thread)

        return True

    def stop_scan(self):
        """Stop the vulnerability scanning process."""
        if not self.running:
            return False

        self.running = False

        # Wait for thread to finish
        if self.scan_thread:
            self.scan_thread.join(timeout=2.0)

        # Update scan result
        self.scan_result.notes = (self.scan_result.notes or "") + "\nVulnerability scanning stopped."
        self.scan_result.save()

        # Unregister from state manager
        from . import state_manager
        process_id = f"port_vuln_scan_{self.scan_result.id}"
        state_manager.unregister_process(process_id)

        return True

    def _run_scan(self):
        """Run the vulnerability scan in a separate thread."""
        try:
            # Get process ID for state manager
            from . import state_manager
            process_id = f"port_vuln_scan_{self.scan_result.id}"

            # Update state manager with initial status
            state_manager.update_process_data(process_id, {
                'progress': self.progress,
                'status_message': self.status_message
            })

            # Get all open ports
            open_ports = list(self.port_info)
            total_ports = len(open_ports)

            if total_ports == 0:
                self.status_message = "No open ports found to scan for vulnerabilities."
                self.progress = 100
                state_manager.update_process_data(process_id, {
                    'progress': self.progress,
                    'status_message': self.status_message,
                    'completed': True
                })
                self.running = False
                return

            # Group ports by service to reduce API calls
            service_groups = {}
            for port in open_ports:
                service_key = f"{port.service_name}:{port.service_version or 'none'}"
                if service_key not in service_groups:
                    service_groups[service_key] = []
                service_groups[service_key].append(port)

            # Process each service group
            processed_ports = 0
            for service_key, ports in service_groups.items():
                if not self.running:
                    break

                service_parts = service_key.split(':')
                service_name = service_parts[0]
                service_version = None if service_parts[1] == 'none' else service_parts[1]

                # Update progress
                self.progress = int((processed_ports / total_ports) * 90)
                self.status_message = f"Scanning {service_name} {service_version or ''} for vulnerabilities..."

                # Update state manager
                state_manager.update_process_data(process_id, {
                    'progress': self.progress,
                    'status_message': self.status_message,
                    'ports_scanned': processed_ports,
                    'total_ports': total_ports
                })

                # Get vulnerabilities for this service (will be cached)
                vulnerabilities = self._get_vulnerabilities_for_service(service_name, service_version)

                # Apply vulnerabilities to all ports with this service
                for port_info in ports:
                    self._apply_vulnerabilities_to_port(port_info, vulnerabilities)
                    processed_ports += 1

                    # Update progress more frequently but with less detail
                    if processed_ports % 3 == 0:
                        progress = int((processed_ports / total_ports) * 90)
                        if progress != self.progress:
                            self.progress = progress
                            state_manager.update_process_data(process_id, {
                                'progress': self.progress,
                                'ports_scanned': processed_ports
                            })

                # Avoid rate limiting between different service checks
                time.sleep(1)

            # Finalize scan
            self.status_message = f"Vulnerability scan completed. Found {len(self.vulnerabilities)} potential vulnerabilities."
            self.progress = 100

            # Update scan result
            self.scan_result.notes = (self.scan_result.notes or "") + f"\nVulnerability scanning completed. Found {len(self.vulnerabilities)} potential vulnerabilities."
            self.scan_result.save()

            # Update state manager with final status
            state_manager.update_process_data(process_id, {
                'progress': 100,
                'status_message': self.status_message,
                'vulnerabilities_found': len(self.vulnerabilities),
                'completed': True
            })

        except Exception as e:
            logger.error(f"Error during vulnerability scan: {str(e)}")
            self.status_message = f"Scan failed: {str(e)}"

            # Update scan result
            self.scan_result.notes = (self.scan_result.notes or "") + f"\nVulnerability scanning failed: {str(e)}"
            self.scan_result.save()

            # Update state manager with error
            state_manager.update_process_data(process_id, {
                'progress': self.progress,
                'status_message': self.status_message,
                'error': str(e),
                'failed': True
            })

        finally:
            self.running = False

            # Unregister process after a delay to allow status to be read
            def delayed_unregister():
                import time
                time.sleep(60)  # Keep process info for 1 minute after completion
                state_manager.unregister_process(process_id)

            threading.Thread(target=delayed_unregister, daemon=True).start()

    # Cache for vulnerability lookups to avoid duplicate API calls
    _vulnerability_cache = {}

    def _get_vulnerabilities_for_service(self, service_name, service_version):
        """Get vulnerabilities for a specific service and version."""
        if not service_name or service_name == 'unknown':
            return []

        # Create cache key
        cache_key = f"{service_name}:{service_version or 'none'}"

        # Check cache first
        if cache_key in self._vulnerability_cache:
            logger.info(f"Using cached vulnerabilities for {cache_key}")
            return self._vulnerability_cache[cache_key]

        # Try different APIs for vulnerability information
        vulnerabilities = []

        # Try NVD API first
        nvd_vulns = self._check_nvd_api(service_name, service_version)
        if nvd_vulns:
            vulnerabilities.extend(nvd_vulns)

        # Try CIRCL API as backup
        if not vulnerabilities:
            circl_vulns = self._check_circl_api(service_name, service_version)
            if circl_vulns:
                vulnerabilities.extend(circl_vulns)

        # Cache the results
        self._vulnerability_cache[cache_key] = vulnerabilities
        return vulnerabilities

    def _apply_vulnerabilities_to_port(self, port_info, vulnerabilities):
        """Apply a list of vulnerabilities to a specific port."""
        if not vulnerabilities:
            return

        service_name = port_info.service_name

        # Save vulnerabilities to database
        for vuln in vulnerabilities:
            # Check if this vulnerability already exists for this target and port
            existing_vulns = Vulnerability.objects.filter(
                target=self.target,
                cve_id=vuln.get('cve_id', ''),
                port_info__port_number=port_info.port_number
            )

            if existing_vulns.exists():
                # Skip creating duplicate vulnerabilities
                continue

            # Create vulnerability record
            vulnerability = Vulnerability.objects.create(
                port_info=port_info,
                target=self.target,
                title=vuln.get('title', ''),
                description=vuln.get('description', ''),
                severity=vuln.get('severity', 'unknown'),
                cve_id=vuln.get('cve_id', ''),
                cvss_score=vuln.get('cvss_score', 0.0),
                affected_component=f"{service_name} on port {port_info.port_number}",
                remediation_steps=vuln.get('remediation', '')
            )

            self.vulnerabilities.append(vulnerability)

    def _check_vulnerabilities(self, port_info):
        """Legacy method for checking vulnerabilities for a specific port/service."""
        service_name = port_info.service_name
        service_version = port_info.service_version

        # Get vulnerabilities for this service
        vulnerabilities = self._get_vulnerabilities_for_service(service_name, service_version)

        # Apply vulnerabilities to this port
        self._apply_vulnerabilities_to_port(port_info, vulnerabilities)

    def _check_nvd_api(self, service_name, service_version):
        """Check the NVD API for vulnerabilities."""
        try:
            # Construct search query
            search_term = service_name
            if service_version:
                search_term += f" {service_version}"

            # Make API request
            params = {
                'keywordSearch': search_term,
                'resultsPerPage': 20
            }

            response = requests.get(NVD_API_URL, params=params, timeout=10)

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []

                # Process results
                for vuln in data.get('vulnerabilities', []):
                    cve = vuln.get('cve', {})

                    # Extract CVE ID
                    cve_id = cve.get('id', '')

                    # Extract description
                    descriptions = cve.get('descriptions', [])
                    description = next((d.get('value', '') for d in descriptions if d.get('lang') == 'en'), '')

                    # Extract metrics
                    metrics = cve.get('metrics', {})
                    cvss_data = metrics.get('cvssMetricV31', [{}])[0] if 'cvssMetricV31' in metrics else \
                               metrics.get('cvssMetricV30', [{}])[0] if 'cvssMetricV30' in metrics else \
                               metrics.get('cvssMetricV2', [{}])[0] if 'cvssMetricV2' in metrics else {}

                    cvss_data = cvss_data.get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore', 0.0)

                    # Determine severity
                    severity = 'unknown'
                    if cvss_score >= 9.0:
                        severity = 'critical'
                    elif cvss_score >= 7.0:
                        severity = 'high'
                    elif cvss_score >= 4.0:
                        severity = 'medium'
                    elif cvss_score > 0:
                        severity = 'low'

                    # Create vulnerability entry
                    vulnerability = {
                        'cve_id': cve_id,
                        'title': f"{service_name} {service_version} - {cve_id}",
                        'description': description,
                        'severity': severity,
                        'cvss_score': cvss_score,
                        'remediation': 'Update to the latest version of the software.'
                    }

                    vulnerabilities.append(vulnerability)

                return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking NVD API: {str(e)}")

        return []

    def _check_circl_api(self, service_name, service_version):
        """Check the CIRCL API for vulnerabilities."""
        try:
            # Construct API URL
            url = f"{CIRCL_API_URL}/search/{service_name}"
            if service_version:
                # Remove any non-alphanumeric characters from version
                clean_version = re.sub(r'[^a-zA-Z0-9.]', '', service_version)
                if clean_version:
                    url += f"/{clean_version}"

            # Make API request
            response = requests.get(url, timeout=10)

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []

                # Process results
                for vuln in data:
                    # Extract CVE ID
                    cve_id = vuln.get('id', '')

                    # Extract description
                    description = vuln.get('summary', '')

                    # Extract CVSS score
                    cvss_score = vuln.get('cvss', 0.0)

                    # Determine severity
                    severity = 'unknown'
                    if cvss_score >= 9.0:
                        severity = 'critical'
                    elif cvss_score >= 7.0:
                        severity = 'high'
                    elif cvss_score >= 4.0:
                        severity = 'medium'
                    elif cvss_score > 0:
                        severity = 'low'

                    # Create vulnerability entry
                    vulnerability = {
                        'cve_id': cve_id,
                        'title': f"{service_name} {service_version} - {cve_id}",
                        'description': description,
                        'severity': severity,
                        'cvss_score': cvss_score,
                        'remediation': 'Update to the latest version of the software.'
                    }

                    vulnerabilities.append(vulnerability)

                return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking CIRCL API: {str(e)}")

        return []

    def get_status(self):
        """Get the current status of the vulnerability scan."""
        return {
            'running': self.running,
            'progress': self.progress,
            'status_message': self.status_message,
            'vulnerabilities_found': len(self.vulnerabilities),
            'scan_id': self.scan_result.id
        }

# Dictionary to store active scanners
active_port_vuln_scanners = {}

def get_port_vuln_scanner(scan_id):
    """Get an active port vulnerability scanner for a scan result."""
    return active_port_vuln_scanners.get(str(scan_id))

def create_port_vuln_scanner(scan_result):
    """Create a new port vulnerability scanner for a scan result."""
    scanner = PortVulnerabilityScanner(scan_result)
    active_port_vuln_scanners[str(scan_result.id)] = scanner
    return scanner

def remove_port_vuln_scanner(scan_id):
    """Remove a port vulnerability scanner from the active scanners list."""
    if str(scan_id) in active_port_vuln_scanners:
        del active_port_vuln_scanners[str(scan_id)]
