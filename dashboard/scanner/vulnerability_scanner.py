"""
Vulnerability Scanner for Rex Security

This module provides vulnerability scanning capabilities that can be used
to identify security issues in target systems.
"""

import socket
import subprocess
import threading
import time
import datetime
import logging
import json
import re
import os
import requests
from django.utils import timezone
from django.conf import settings
from .models import Target, VulnerabilityCheckup, Vulnerability

# Configure logging
logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """
    Vulnerability scanning system that identifies security issues
    in target systems using various scanning techniques.
    """

    def __init__(self, target, scan_type='standard'):
        """
        Initialize the vulnerability scanner.

        Args:
            target (Target): Target system to scan
            scan_type (str): Type of scan to perform (quick, standard, deep)
        """
        self.target = target
        self.scan_type = scan_type
        self.checkup = None
        self.vulnerabilities = []
        self.running = False
        self.scan_thread = None
        self.progress = 0
        self.status_message = "Initializing..."

        # Load vulnerability database
        self.load_vulnerability_database()

    def load_vulnerability_database(self):
        """Load vulnerability definitions from local database."""
        # Path to vulnerability database
        db_path = os.path.join(settings.BASE_DIR, 'scanner', 'vulnerability_db')

        # Initialize empty database
        self.vuln_db = {
            'cve_data': {},
            'service_vulns': {},
            'os_vulns': {},
            'web_vulns': {}
        }

        # Load CVE data if file exists
        cve_file = os.path.join(db_path, 'cve_data.json')
        if os.path.exists(cve_file):
            try:
                with open(cve_file, 'r') as f:
                    self.vuln_db['cve_data'] = json.load(f)
            except Exception as e:
                logger.error(f"Error loading CVE database: {str(e)}")

        # Load service vulnerabilities if file exists
        service_file = os.path.join(db_path, 'service_vulns.json')
        if os.path.exists(service_file):
            try:
                with open(service_file, 'r') as f:
                    self.vuln_db['service_vulns'] = json.load(f)
            except Exception as e:
                logger.error(f"Error loading service vulnerabilities: {str(e)}")

        # Load OS vulnerabilities if file exists
        os_file = os.path.join(db_path, 'os_vulns.json')
        if os.path.exists(os_file):
            try:
                with open(os_file, 'r') as f:
                    self.vuln_db['os_vulns'] = json.load(f)
            except Exception as e:
                logger.error(f"Error loading OS vulnerabilities: {str(e)}")

        # Load web vulnerabilities if file exists
        web_file = os.path.join(db_path, 'web_vulns.json')
        if os.path.exists(web_file):
            try:
                with open(web_file, 'r') as f:
                    self.vuln_db['web_vulns'] = json.load(f)
            except Exception as e:
                logger.error(f"Error loading web vulnerabilities: {str(e)}")

    def start_scan(self):
        """Start the vulnerability scanning process."""
        if self.running:
            return False

        # Create a new vulnerability checkup record
        self.checkup = VulnerabilityCheckup.objects.create(
            target=self.target,
            status='in_progress',
            scan_type=self.scan_type
        )

        self.running = True
        self.progress = 0
        self.status_message = "Starting vulnerability scan..."

        # Register with state manager
        from . import state_manager
        process_id = f"vulnerability_scan_{self.checkup.id}"
        state_manager.register_process(process_id, 'vulnerability_scan', {
            'checkup_id': self.checkup.id,
            'target_id': str(self.target.id),
            'scan_type': self.scan_type
        })

        # Start scan thread
        self.scan_thread = threading.Thread(target=self._run_scan)
        self.scan_thread.daemon = True
        self.scan_thread.start()

        # Register thread with state manager
        state_manager.register_thread(process_id, self.scan_thread)

        return True

    def stop_scan(self):
        """Stop the vulnerability scanning process."""
        if not self.running:
            return False

        self.running = False

        # Wait for thread to finish
        if self.scan_thread:
            self.scan_thread.join(timeout=2.0)

        # Update checkup status
        if self.checkup:
            self.checkup.status = 'failed'
            self.checkup.save()

            # Unregister from state manager
            from . import state_manager
            process_id = f"vulnerability_scan_{self.checkup.id}"
            state_manager.unregister_process(process_id)

        return True

    def _run_scan(self):
        """Run the vulnerability scan in a separate thread."""
        start_time = timezone.now()

        # Get process ID for state manager
        from . import state_manager
        process_id = f"vulnerability_scan_{self.checkup.id}"

        try:
            self.status_message = "Initializing vulnerability scan..."
            self.progress = 5

            # Update state manager with initial status
            state_manager.update_process_data(process_id, {
                'progress': self.progress,
                'status_message': self.status_message
            })

            # Connect to the agent and run the vulnerability scan
            self.status_message = "Connecting to agent..."
            self.progress = 10

            # Update state manager with progress
            state_manager.update_process_data(process_id, {
                'progress': self.progress,
                'status_message': self.status_message
            })

            try:
                # Import the host controller module using direct import
                import sys
                import os
                import importlib.util

                # Get the current directory
                current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

                # Import host_controller.py
                host_controller_path = os.path.join(current_dir, "proto", "host", "host_controller.py")
                self.status_message = f"Loading host controller module..."

                if os.path.exists(host_controller_path):
                    spec = importlib.util.spec_from_file_location("host_controller", host_controller_path)
                    host_controller = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(host_controller)
                    send_command = host_controller.send_command
                else:
                    raise ImportError(f"Host controller module not found at {host_controller_path}")

                # Import protocol.py
                protocol_path = os.path.join(current_dir, "proto", "pro", "protocol.py")
                self.status_message = f"Loading protocol module..."

                if os.path.exists(protocol_path):
                    spec = importlib.util.spec_from_file_location("protocol", protocol_path)
                    protocol = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(protocol)
                    CMD_VULNERABILITY_SCAN = protocol.CMD_VULNERABILITY_SCAN
                else:
                    raise ImportError(f"Protocol module not found at {protocol_path}")

                # Send the vulnerability scan command to the agent
                self.status_message = f"Connecting to agent at {self.target.ip_address}..."
                self.progress = 10

                # Try to connect to the agent
                self.status_message = f"Running {self.scan_type} vulnerability scan on agent..."
                self.progress = 20

                # Send the scan type as the payload with verbose output
                self.status_message = f"Sending vulnerability scan command to agent..."
                self.progress = 20

                # Log the request details
                logger.info(f"Sending vulnerability scan command to agent at {self.target.ip_address}")
                logger.info(f"Scan type: {self.scan_type}")
                logger.info(f"Command code: {CMD_VULNERABILITY_SCAN} (0x{CMD_VULNERABILITY_SCAN:02X})")

                # Try to connect to the agent
                try:
                    # Send the command to the agent
                    response = send_command(self.target.ip_address, CMD_VULNERABILITY_SCAN, self.scan_type, verbose=True)

                    # Log the response
                    if response:
                        logger.info(f"Response received from agent (length: {len(response) if response else 0})")
                        if isinstance(response, str) and len(response) > 100:
                            logger.info(f"Response preview: {response[:100]}...")
                    else:
                        logger.error(f"No response received from agent")

                except Exception as conn_error:
                    logger.error(f"Exception while connecting to agent: {str(conn_error)}")
                    self.status_message = f"Failed to connect to agent: {str(conn_error)}"
                    raise ConnectionError(f"Failed to connect to agent at {self.target.ip_address}: {str(conn_error)}")

                if response is None:
                    logger.error(f"No response received from agent at {self.target.ip_address}")
                    self.status_message = f"No response received from agent"
                    raise ConnectionError(f"Failed to connect to agent at {self.target.ip_address}: No response received")

                # Parse the JSON response
                self.status_message = "Processing scan results from agent..."
                self.progress = 80

                try:
                    # Handle both string and bytes responses
                    if isinstance(response, bytes):
                        response_str = response.decode('utf-8', errors='replace')
                        logger.info("Decoded bytes response to string")
                    else:
                        response_str = response
                        logger.info("Response was already a string")

                    # Log the response preview
                    logger.info(f"Response preview for JSON parsing: {response_str[:200]}...")

                    # Parse the JSON response
                    scan_results = json.loads(response_str)
                    logger.info("Successfully parsed JSON response")

                except json.JSONDecodeError as e:
                    # If we can't parse the JSON, show the first 100 characters of the response
                    preview = response[:100] if isinstance(response, bytes) else response[:100]
                    error_msg = f"Invalid JSON response from agent: {str(e)}. Response preview: {preview}"
                    logger.error(error_msg)
                    self.status_message = "Error parsing response from agent"
                    raise Exception(error_msg)

                # Check if the scan was successful
                if scan_results.get('status') == 'completed':
                    # Extract vulnerabilities from the scan results
                    vulnerabilities = scan_results.get('vulnerabilities', [])

                    # Count vulnerabilities by severity
                    high_count = len([v for v in vulnerabilities if v.get('severity') in ['high', 'critical']])
                    medium_count = len([v for v in vulnerabilities if v.get('severity') == 'medium'])
                    low_count = len([v for v in vulnerabilities if v.get('severity') == 'low'])

                    # Update the checkup with the counts
                    self.checkup.total_vulnerabilities = len(vulnerabilities)
                    self.checkup.high_vulnerabilities = high_count
                    self.checkup.medium_vulnerabilities = medium_count
                    self.checkup.low_vulnerabilities = low_count
                    self.checkup.status = 'completed'
                    self.checkup.save()

                    # Add each vulnerability to the database
                    for vuln in vulnerabilities:
                        Vulnerability.objects.create(
                            checkup=self.checkup,
                            target=self.target,
                            title=vuln.get('title', 'Unknown Vulnerability'),
                            description=vuln.get('description', ''),
                            severity=vuln.get('severity', 'medium'),
                            cve_id=vuln.get('cve_id'),
                            affected_component=vuln.get('affected_component', 'Unknown'),
                            remediation_steps=vuln.get('remediation_steps', '')
                        )

                    # Update status message
                    self.status_message = f"Scan completed: Found {len(vulnerabilities)} vulnerabilities"
                    logger.info(f"Vulnerability scan completed successfully. Found {len(vulnerabilities)} vulnerabilities.")

                else:
                    # Scan failed
                    error_message = scan_results.get('error', 'Unknown error')
                    self.status_message = f"Scan failed on agent: {error_message}"
                    self.checkup.status = 'failed'
                    self.checkup.save()
                    logger.error(f"Vulnerability scan failed: {error_message}")
                    raise Exception(error_message)

            except (ImportError, ModuleNotFoundError):
                # Fall back to local scanning if agent communication fails
                self.status_message = "Agent communication failed. Falling back to local scanning..."
                self.progress = 15

                # Determine scan depth based on scan type
                if self.scan_type == 'quick':
                    port_range = '21-23,25,53,80,443,3389'
                    timeout = 0.5
                elif self.scan_type == 'standard':
                    port_range = '1-1024'
                    timeout = 1.0
                else:  # deep scan
                    port_range = '1-65535'
                    timeout = 2.0

                # Step 1: Port scanning
                self.status_message = "Scanning for open ports..."
                self.progress = 20
                open_ports = self._scan_ports(port_range, timeout)

                if not self.running:
                    return

                # Step 2: Service detection
                self.status_message = "Detecting services on open ports..."
                self.progress = 30
                services = self._detect_services(open_ports)

                if not self.running:
                    return

                # Step 3: OS detection
                self.status_message = "Detecting operating system..."
                self.progress = 40
                os_info = self._detect_os()

                if not self.running:
                    return

                # Step 4: Check for known vulnerabilities in services
                self.status_message = "Checking for service vulnerabilities..."
                self.progress = 50
                self._check_service_vulnerabilities(services)

                if not self.running:
                    return

                # Step 5: Check for OS vulnerabilities
                self.status_message = "Checking for OS vulnerabilities..."
                self.progress = 60
                self._check_os_vulnerabilities(os_info)

                if not self.running:
                    return

                # Step 6: Web application scanning (if web servers found)
                web_ports = [port for port, service in services.items()
                            if 'http' in service.lower() or port in [80, 443, 8080, 8443]]

                if web_ports:
                    self.status_message = "Scanning web applications..."
                    self.progress = 70
                    self._scan_web_applications(web_ports)

                if not self.running:
                    return

                # Step 7: Network configuration checks
                self.status_message = "Checking network configurations..."
                self.progress = 80
                self._check_network_configurations()

            # Finalize scan
            self.status_message = "Finalizing scan results..."
            self.progress = 95

            # Update checkup with results
            end_time = timezone.now()
            self.checkup.status = 'completed'
            self.checkup.scan_duration = end_time - start_time
            self.checkup.total_vulnerabilities = len(self.vulnerabilities)
            self.checkup.high_vulnerabilities = sum(1 for v in self.vulnerabilities if v['severity'] == 'high' or v['severity'] == 'critical')
            self.checkup.medium_vulnerabilities = sum(1 for v in self.vulnerabilities if v['severity'] == 'medium')
            self.checkup.low_vulnerabilities = sum(1 for v in self.vulnerabilities if v['severity'] == 'low')
            self.checkup.save()

            # Save vulnerabilities to database
            for vuln in self.vulnerabilities:
                Vulnerability.objects.create(
                    checkup=self.checkup,
                    target=self.target,
                    title=vuln['title'],
                    description=vuln['description'],
                    severity=vuln['severity'],
                    cve_id=vuln.get('cve_id'),
                    affected_component=vuln['affected_component'],
                    remediation_steps=vuln['remediation_steps'],
                    status='open'
                )

            self.status_message = "Scan completed successfully."
            self.progress = 100

            # Update state manager with final status
            state_manager.update_process_data(process_id, {
                'progress': 100,
                'status_message': self.status_message,
                'total_vulnerabilities': len(self.vulnerabilities),
                'high_vulnerabilities': self.checkup.high_vulnerabilities,
                'medium_vulnerabilities': self.checkup.medium_vulnerabilities,
                'low_vulnerabilities': self.checkup.low_vulnerabilities,
                'completed': True
            })

        except Exception as e:
            logger.error(f"Error during vulnerability scan: {str(e)}")
            self.status_message = f"Scan failed: {str(e)}"

            # Update checkup status
            if self.checkup:
                self.checkup.status = 'failed'
                self.checkup.save()

            # Update state manager with error
            state_manager.update_process_data(process_id, {
                'progress': self.progress,
                'status_message': self.status_message,
                'error': str(e),
                'failed': True
            })

        finally:
            self.running = False

            # Unregister process after a delay to allow status to be read
            def delayed_unregister():
                import time
                time.sleep(60)  # Keep process info for 1 minute after completion
                state_manager.unregister_process(process_id)

            threading.Thread(target=delayed_unregister, daemon=True).start()

    def _scan_ports(self, port_range, timeout):
        """Scan for open ports on the target system."""
        open_ports = {}

        # Parse port range
        ports_to_scan = self._parse_port_range(port_range)
        total_ports = len(ports_to_scan)

        for i, port in enumerate(ports_to_scan):
            if not self.running:
                break

            # Update progress periodically
            if i % 100 == 0:
                self.progress = 5 + int((i / total_ports) * 15)
                self.status_message = f"Scanning port {port}..."

            try:
                # Create socket and attempt to connect
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(timeout)
                result = s.connect_ex((self.target.ip_address, port))

                if result == 0:
                    open_ports[port] = 'Unknown'

                s.close()

            except Exception:
                continue

        return open_ports

    def _parse_port_range(self, port_range):
        """Parse a port range string into a list of ports."""
        ports = []

        # Split by comma
        for part in port_range.split(','):
            if '-' in part:
                # Handle range (e.g., 1-1024)
                start, end = part.split('-')
                ports.extend(range(int(start), int(end) + 1))
            else:
                # Handle single port
                ports.append(int(part))

        return ports

    def _detect_services(self, open_ports):
        """Detect services running on open ports."""
        services = {}
        total_ports = len(open_ports)

        for i, (port, _) in enumerate(open_ports.items()):
            if not self.running:
                break

            # Update progress periodically
            if i % 10 == 0:
                self.progress = 20 + int((i / total_ports) * 10)
                self.status_message = f"Detecting service on port {port}..."

            try:
                # Try to get service banner
                service = self._get_service_banner(port)
                services[port] = service
            except Exception:
                services[port] = 'Unknown'

        return services

    def _get_service_banner(self, port):
        """Get service banner from a specific port."""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(2.0)
            s.connect((self.target.ip_address, port))

            # Send request based on common protocols
            if port == 80 or port == 8080:
                s.send(b"GET / HTTP/1.1\r\nHost: " + self.target.ip_address.encode() + b"\r\n\r\n")
            elif port == 21:
                pass  # FTP servers usually send banner automatically
            elif port == 22:
                pass  # SSH servers usually send banner automatically
            elif port == 25 or port == 587:
                pass  # SMTP servers usually send banner automatically
            else:
                # For unknown services, try sending a newline
                s.send(b"\r\n")

            # Receive response
            banner = s.recv(1024)
            s.close()

            # Decode and clean banner
            banner_str = banner.decode('utf-8', errors='ignore').strip()

            # Identify service based on banner
            if 'SSH' in banner_str:
                return f"SSH: {banner_str}"
            elif 'FTP' in banner_str:
                return f"FTP: {banner_str}"
            elif 'SMTP' in banner_str:
                return f"SMTP: {banner_str}"
            elif 'HTTP' in banner_str:
                return f"HTTP: {banner_str.splitlines()[0]}"
            elif port == 80 or port == 443 or port == 8080 or port == 8443:
                return "HTTP/HTTPS"
            else:
                return banner_str if banner_str else "Unknown"

        except Exception:
            # Common services by port
            common_ports = {
                21: 'FTP',
                22: 'SSH',
                23: 'Telnet',
                25: 'SMTP',
                53: 'DNS',
                80: 'HTTP',
                110: 'POP3',
                143: 'IMAP',
                443: 'HTTPS',
                445: 'SMB',
                3306: 'MySQL',
                3389: 'RDP',
                5432: 'PostgreSQL',
                8080: 'HTTP-Proxy'
            }

            return common_ports.get(port, "Unknown")

    def _detect_os(self):
        """Detect the operating system of the target."""
        os_info = {
            'os_name': 'Unknown',
            'os_version': 'Unknown',
            'os_family': 'Unknown'
        }

        try:
            # Try to get OS info from TTL in ping response
            output = subprocess.check_output(
                ["ping", "-n", "1", "-w", "1000", self.target.ip_address],
                stderr=subprocess.STDOUT,
                text=True
            )

            # Extract TTL value
            ttl_match = re.search(r'TTL=(\d+)', output)
            if ttl_match:
                ttl = int(ttl_match.group(1))

                # Estimate OS based on TTL
                if ttl <= 64:
                    os_info['os_family'] = 'Unix/Linux'
                elif ttl <= 128:
                    os_info['os_family'] = 'Windows'
                else:
                    os_info['os_family'] = 'Solaris/AIX'

        except Exception:
            pass

        return os_info

    def _check_service_vulnerabilities(self, services):
        """Check for known vulnerabilities in detected services."""
        for port, service_banner in services.items():
            if not self.running:
                break

            self.status_message = f"Checking vulnerabilities for service on port {port}..."

            # Extract service name
            service_name = service_banner.split(':')[0] if ':' in service_banner else service_banner
            service_name = service_name.lower()

            # Check for known vulnerabilities in this service
            for vuln_id, vuln_info in self.vuln_db['service_vulns'].items():
                if not self.running:
                    break

                # Check if this vulnerability applies to this service
                if any(s.lower() in service_name for s in vuln_info.get('affected_services', [])):
                    # Check version if available
                    if 'version_pattern' in vuln_info:
                        version_match = re.search(vuln_info['version_pattern'], service_banner)
                        if not version_match:
                            continue

                    # Add vulnerability
                    self.vulnerabilities.append({
                        'title': vuln_info['title'],
                        'description': vuln_info['description'],
                        'severity': vuln_info['severity'],
                        'cve_id': vuln_info.get('cve_id'),
                        'affected_component': f"{service_name} on port {port}",
                        'remediation_steps': vuln_info['remediation']
                    })

    def _check_os_vulnerabilities(self, os_info):
        """Check for known vulnerabilities in the detected OS."""
        os_family = os_info['os_family'].lower()

        for vuln_id, vuln_info in self.vuln_db['os_vulns'].items():
            if not self.running:
                break

            # Check if this vulnerability applies to this OS
            if any(os.lower() in os_family for os in vuln_info.get('affected_os', [])):
                # Add vulnerability
                self.vulnerabilities.append({
                    'title': vuln_info['title'],
                    'description': vuln_info['description'],
                    'severity': vuln_info['severity'],
                    'cve_id': vuln_info.get('cve_id'),
                    'affected_component': os_info['os_family'],
                    'remediation_steps': vuln_info['remediation']
                })

    def _scan_web_applications(self, web_ports):
        """Scan web applications for vulnerabilities."""
        for port in web_ports:
            if not self.running:
                break

            self.status_message = f"Scanning web application on port {port}..."

            # Determine protocol (HTTP or HTTPS)
            protocol = 'https' if port == 443 or port == 8443 else 'http'
            url = f"{protocol}://{self.target.ip_address}:{port}"

            try:
                # Basic checks
                self._check_web_headers(url, port)
                self._check_common_web_vulnerabilities(url, port)
            except Exception as e:
                logger.error(f"Error scanning web application on port {port}: {str(e)}")

    def _check_web_headers(self, url, port):
        """Check HTTP headers for security issues."""
        try:
            response = requests.get(url, timeout=5, verify=False)
            headers = response.headers

            # Check for missing security headers
            security_headers = {
                'Strict-Transport-Security': 'Missing HSTS header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'X-Frame-Options': 'Missing X-Frame-Options header',
                'Content-Security-Policy': 'Missing Content-Security-Policy header'
            }

            for header, message in security_headers.items():
                if header not in headers:
                    self.vulnerabilities.append({
                        'title': message,
                        'description': f"The web server is missing the {header} security header, which helps protect against certain types of attacks.",
                        'severity': 'medium',
                        'affected_component': f"Web server on port {port}",
                        'remediation_steps': f"Configure the web server to include the {header} header in HTTP responses."
                    })

            # Check for information disclosure in headers
            info_disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version']
            for header in info_disclosure_headers:
                if header in headers:
                    self.vulnerabilities.append({
                        'title': f"Information disclosure in {header} header",
                        'description': f"The web server is revealing potentially sensitive information through the {header} header: {headers[header]}",
                        'severity': 'low',
                        'affected_component': f"Web server on port {port}",
                        'remediation_steps': f"Configure the web server to remove or obfuscate the {header} header."
                    })

        except requests.exceptions.RequestException:
            pass

    def _check_common_web_vulnerabilities(self, url, port):
        """Check for common web vulnerabilities."""
        # This would be a simplified version - in a real implementation,
        # you would use more sophisticated techniques or integrate with
        # tools like OWASP ZAP or Burp Suite

        # Check for common sensitive files
        sensitive_files = ['/robots.txt', '/sitemap.xml', '/.git/', '/.env', '/wp-config.php', '/config.php']

        for file_path in sensitive_files:
            if not self.running:
                break

            try:
                response = requests.get(url + file_path, timeout=2, verify=False)

                if response.status_code == 200:
                    self.vulnerabilities.append({
                        'title': f"Sensitive file exposed: {file_path}",
                        'description': f"The web server is exposing a potentially sensitive file at {url + file_path}",
                        'severity': 'medium',
                        'affected_component': f"Web server on port {port}",
                        'remediation_steps': f"Remove or restrict access to the sensitive file {file_path}."
                    })

            except requests.exceptions.RequestException:
                continue

    def _check_network_configurations(self):
        """Check for network configuration vulnerabilities."""
        # This would be a simplified version - in a real implementation,
        # you would perform more comprehensive checks

        # Example: Check if common insecure ports are open
        insecure_ports = {
            23: "Telnet",
            445: "SMB",
            135: "RPC",
            137: "NetBIOS",
            138: "NetBIOS",
            139: "NetBIOS"
        }

        for port, service in insecure_ports.items():
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(0.5)
                result = s.connect_ex((self.target.ip_address, port))
                s.close()

                if result == 0:
                    self.vulnerabilities.append({
                        'title': f"Insecure service exposed: {service}",
                        'description': f"The system is running {service} on port {port}, which is considered insecure and should be disabled or replaced with a secure alternative.",
                        'severity': 'high',
                        'affected_component': f"{service} on port {port}",
                        'remediation_steps': f"Disable {service} or replace it with a secure alternative. If necessary, restrict access using a firewall."
                    })

            except Exception:
                continue

    def get_status(self):
        """Get the current status of the vulnerability scan."""
        return {
            'running': self.running,
            'progress': self.progress,
            'status_message': self.status_message,
            'vulnerabilities_found': len(self.vulnerabilities),
            'checkup_id': self.checkup.id if self.checkup else None
        }

    def _add_vulnerability(self, title, description, severity, cve_id=None, affected_component='Unknown', remediation=''):
        """
        Legacy method for adding a vulnerability to the database.
        This method is kept for backward compatibility but is no longer used.
        Vulnerabilities are now added directly from the scan results.
        """
        try:
            # Create the vulnerability
            vulnerability = Vulnerability.objects.create(
                checkup=self.checkup,
                target=self.target,
                title=title,
                description=description,
                severity=severity,
                cve_id=cve_id,
                affected_component=affected_component,
                remediation_steps=remediation
            )

            logger.info(f"Added vulnerability: {title}")
            return vulnerability
        except Exception as e:
            logger.error(f"Error adding vulnerability: {str(e)}")
            return None


# Dictionary to store active scanners
active_scanners = {}

def get_scanner(target_id):
    """Get an active scanner for a target."""
    return active_scanners.get(str(target_id))

def create_scanner(target, scan_type='standard'):
    """Create a new scanner for a target."""
    scanner = VulnerabilityScanner(target, scan_type)
    active_scanners[str(target.id)] = scanner
    return scanner

def remove_scanner(target_id):
    """Remove a scanner from the active scanners list."""
    if str(target_id) in active_scanners:
        del active_scanners[str(target_id)]
